1. Безпека: Архітектура Backend-for-Frontend (BFF)
Проблема: Зараз API-ключі (Google Gemini, Firebase) зберігаються на клієнті (process.env у Vite потрапляє в бандл). Це означає, що будь-який користувач може вкрасти ваш ключ і використати квоту. Також, прямі запити до Gemini з браузера обмежують можливості кешування та складної логіки.
Рішення:
Створити легкий Backend: Використовуйте Next.js API Routes, Vercel Functions або Cloudflare Workers.
Проксіювання запитів: Клієнт відправляє запит на ваш сервер, а сервер додає API-ключ і пересилає запит до Google.
Rate Limiting: На бекенді можна налаштувати ліміти запитів для кожного користувача, щоб уникнути зловживань.
2. Рефакторинг стану: Повна міграція на Zustand + Yjs
Проблема: У коді спостерігається змішування підходів. App.tsx все ще містить багато локального стану (useState) і логіки (useEffect), хоча вже створено src/store. Також є паралельна логіка синхронізації через peerService (ручні повідомлення) та crdtService (Yjs). Це призводить до "Race Conditions" і складнощів у підтримці.
Рішення:
App.tsx як Router: Очистити App.tsx, залишивши тільки маршрутизацію. Вся логіка має бути в хуках або сторі.
Єдине джерело правди: Зробити Yjs (через crdtService) основним сховищем даних для всього, що потрібно синхронізувати (карта, токени, чат). Zustand має бути лише реактивною обгорткою над Yjs для UI.
Відмова від ручних подій: Замість peerService.broadcast({ type: 'MOVE_TOKEN' }), просто оновлюйте Yjs документ. Yjs автоматично розішле дельти всім клієнтам.
3. Оптимізація ШІ: Просунутий RAG та Контекст
Проблема: Зараз у Gemini відправляється майже вся історія чату та опис стану. Це швидко вичерпує ліміт токенів (Context Window) і здорожчує запити. Пошук через ragService реалізовано, але він досить базовий.
Рішення:
Векторна БД: Інтегрувати серйозніше рішення для векторного пошуку (наприклад, клієнтський Voy або серверний Pinecone), щоб зберігати весь лор світу, бестіарій та правила.
Context Summarization: Замість передачі сирого логу чату, реалізувати фоновий процес, який кожні 10 повідомлень створює стислий "зліпок ситуації" і замінює ним старі повідомлення в промпті.
Structured Outputs: Суворіше типізувати відповіді від Gemini. Використовувати responseSchema не тільки для генерації JSON, а й для звичайних відповідей, щоб чітко розділяти "думки" моделі, "опис для гравців" і "технічні команди".
4. Продуктивність VTT: Оптимізація Рендерингу Мапи
Проблема: BattleMap.tsx виконує багато важких обчислень (Raycasting для туману війни) прямо в React-компоненті та використовує Canvas 2D API. При великій кількості об'єктів або частинок це може викликати падіння FPS.
Рішення:
OffscreenCanvas: Винести рендеринг мапи та туману війни у Web Worker. Це розблокує UI-потік (Main Thread).
Шари (Layers): Чітко розділити статичні шари (фон, сітка) та динамічні (токени, ефекти). Статичні шари не повинні перемальовуватися при русі токена.
WebGL / Бібліотеки: Розглянути перехід на PixiJS або Konva. Вони набагато ефективніше працюють з графікою та подіями миші, ніж чистий Canvas API.
5. Покращення UX: "Живий" Інтерфейс та Моддінг
Проблема: Інтерфейс перевантажений модальними вікнами, які перекривають гру. Система модів (ModManager) є, але вона базова (тільки JSON).
Рішення:
Docking System: Дозволити користувачам перетягувати та закріплювати панелі (чат, інвентар, дайси) в різних частинах екрану, як у професійних VTT (Foundry, Roll20).
Drag & Drop Everything: Реалізувати можливість перетягувати предмети з чату в інвентар, монстрів з бестіарію на мапу, закляття на токени для атаки.
Scripting API: Розширити систему модів, дозволивши виконувати безпечний JavaScript (наприклад, через QuickJS у пісочниці), щоб користувачі могли створювати власні макроси та автоматизації.